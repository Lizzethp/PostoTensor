# -*- coding: utf-8 -*-
"""PostoTensores2x2x2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EYMPTdviLnMvegYG5fETbLl4Rv8qzx-d
"""

# Posto de Tensores 2×2×2
#
# Este projeto implementa um algoritmo para verificar o posto de tensores
# 2×2×2 sobre os corpos reais (ℝ) e complexos (ℂ).
#
# Referência:
# Ten Berge, J. M. "Kruskal’s polynomial for 2 × 2 × 2 arrays and a
# generalization to 2 × n × n arrays." Psychometrika 56, 4 (1991), 631–636.


# O algoritmo:
# Verifica se a lista é nula e se é superdiagonal.
# Analisa as fatias do tensor para verificar se são singulares.
# Detecta se existem fatias que são múltiplos escalares.
# Calcula o Hiperdeterminante de Cayley para distinguir casos especiais.
# Retorna um resultado textual indicando o posto do tensor de acordo com as condições do teorema aplicado.

# Primeiro, construímos um tensor a partir do produto tensorial de três fatores.
# Deixamos exemplos de listas nos comentários para calcular seu posto, caso o leitor queira testar os diferentes postos.


# Usamos a seguinte convenção para o produto tensorial de três vetores a=[a1, a2], b = [b1, b2] e c = [c1, c2]:
# a⊗b=[a1b1, a1b2, a2b1, a2b2]
# a⊗b⊗c=[a1b1c1, a1b2c1, a2b1c1, a2b2c1, a1b1c2, a1b2c2, a2b1c2, a2b2c2]

import numpy as np
def produto_tensorial(a, b, c):
    """
    Produto tensorial a⊗b⊗c.
    Devolve uma lista na ordem:
      [a1*b1*c1, a1*b2*c1, a2*b1*c1, a2*b2*c1,
       a1*b1*c2, a1*b2*c2, a2*b1*c2, a2*b2*c2]
    """
    a1, a2 = a
    b1, b2 = b
    c1, c2 = c

    lista = [
       a1*b1*c1, a1*b2*c1, a2*b1*c1, a2*b2*c1,
       a1*b1*c2, a1*b2*c2, a2*b1*c2, a2*b2*c2
    ]
    return lista

def soma_tensores(tensores):
    return list(np.sum(np.array(tensores), axis=0))

# Exemplos (use um por vez)

# Base
a1 = [2, 1]; b1 = [1, -2]; c1 = [-2, -3]
lista1 = produto_tensorial(a1, b1, c1)

# Permutação de fatores
lista2 = produto_tensorial(c1, a1, b1)
lista3 = produto_tensorial(b1, c1, a1)

# Soma de tensores
lista4 = soma_tensores([lista1, lista2])
lista5 = soma_tensores([lista1, lista2, lista3])

# Superdiagonal
lista6 = [0, 0, 0, 1, 1, 0, 0, 0]

# Fatias múltiplas
lista7 = [-1, 7, 2, 0, -2, 14, 4, 0]

# Todas as fatias singulares
lista8 = [-1, 0, 5, 0, -6, 0, 30, 0]

# Hiperdeterminante de Cayley negativo
lista9 = [2, 0, 0, 1, 0, 3, -5, 0]

# Hiperdeterminante de Cayley positivo
lista10 = [2, 5, -6, -8, 4, 10, -12, 0]

# Exemplo: hiperdeterminante zero e sem fatias múltiplas
lista11 = [1, -1, 3, 3, 3, -1, -3, 3]

# mude a linha abaixo para lista2, ..., lista11 para testar outros casos
lista = lista9

# Mostrar fatias do tensor
def mostrar_fatias(tensor):
    # Fatias frontais (fixo k)
    print("Fatias frontais:")
    fatias_frontais = []
    for k in range(tensor.shape[2]):
        f = tensor[:, :, k]
        fatias_frontais.append(f)
        print(f"Fatia frontal k={k}:")
        print(f)

    # Fatias horizontais (fixo i)
    print("\nFatias horizontais:")
    fatias_horizontais = []
    for i in range(tensor.shape[0]):
        f = tensor[i, :, :]
        fatias_horizontais.append(f)
        print(f"Fatia horizontal i={i}:")
        print(f)

    # Fatias verticais (fixo j)
    print("\nFatias verticais:")
    fatias_verticais = []
    for j in range(tensor.shape[1]):
        f = tensor[:, j, :]
        fatias_verticais.append(f)
        print(f"Fatia vertical j={j}:")
        print(f)

    return fatias_frontais, fatias_horizontais, fatias_verticais


# Passo 1: verifica se a lista é nula
def passo_1(lista):
    return np.all(np.array(lista) == 0)


# Passo 2: verifica se a lista é superdiagonal
def passo_2(lista):
    if lista[0] != 0 and lista[7] != 0 and all(x == 0 for x in lista[1:7]):
        return True
    if lista[1] != 0 and lista[6] != 0 and all(x == 0 for x in [lista[0], lista[2], lista[3], lista[4], lista[5], lista[7]]):
        return True
    if lista[2] != 0 and lista[5] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[3], lista[4], lista[6], lista[7]]):
        return True
    if lista[3] != 0 and lista[4] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[2], lista[5], lista[6], lista[7]]):
        return True
    return False


# Passo 3: verifica se todas as fatias são singulares
def passo_3(lista):

    # Reconstruir tensor 2x2x2
    tensor = np.array([
        [[lista[0], lista[4]], [lista[1], lista[5]]],
        [[lista[2], lista[6]], [lista[3], lista[7]]]
    ])

    fatias_frontais, fatias_horizontais, fatias_verticais = mostrar_fatias(tensor)
    todas_fatias = fatias_frontais + fatias_horizontais + fatias_verticais

    # Verificar singularidade de cada fatia
    todas_singulares = all(
        abs(np.linalg.det(f)) < 1e-12 for f in todas_fatias
    )
    return todas_singulares, fatias_frontais, fatias_horizontais, fatias_verticais

# Verifica se duas matrizes são múltiplos escalares
def e_multiplo_escalar(matriz1, matriz2):
    if np.all(matriz1 == 0) or np.all(matriz2 == 0):
        return True
    indices = np.argwhere(matriz1 != 0)
    i, j = indices[0]
    ratio = matriz2[i, j] / matriz1[i, j]
    for x in range(matriz1.shape[0]):
        for y in range(matriz1.shape[1]):
            if not np.isclose(matriz2[x, y], ratio * matriz1[x, y]):
                return False
    return True

# Passo 4: verifica se há fatias múltiplos escalares
def passo_4(fatias):
    return e_multiplo_escalar(fatias[0], fatias[1])

# Cálculo do hiperdeterminante de Cayley
def calcular_hiperdeterminante(lista):
    a, b, c, d, e, f, g, h = lista

    delta = (
        a**2 * h**2 + b**2 * g**2 + c**2 * f**2 + d**2 * e**2
        - 2 * (a*b*g*h + a*c*f*h + a*d*e*h
               + b*c*f*g + b*d*e*g + c*d*e*f)
        + 4 * (a*d*f*g + b*c*e*h)
    )
    return delta

# Função principal
def verificar_posto(lista):
    # Reconstruir o tensor a partir da lista
    tensor = np.array([
        [[lista[0], lista[4]], [lista[1], lista[5]]],
        [[lista[2], lista[6]], [lista[3], lista[7]]]
    ])
    # Passo 1: nula
    if passo_1(lista):
        return "A lista é nula, tem posto 0."

    # Passo 2: superdiagonal
    if passo_2(lista):
        return "A lista é superdiagonal, tem posto 2."

    # Passo 3: verificar se todas as fatias são singulares

    todas_singulares, fatias_frontais, fatias_horizontais, fatias_verticais = passo_3(lista)

    # Se todas são singulares -> posto 1
    if todas_singulares:
        return "A lista é de posto 1, todas as fatias são singulares."

    # Passo 4: múltiplos escalares
    if (passo_4(fatias_frontais) or
        passo_4(fatias_horizontais) or
        passo_4(fatias_verticais)):
        return "O tensor é de posto 2, existe um par de fatias múltiplas escalares."


    # Passo 5: Hiperdeterminante de Cayley
    delta = calcular_hiperdeterminante(lista)

    # Casos do teorema (T2 não múltiplo de T1):
    if abs(delta) < 1e-12:
        return "O hiperdeterminante de Cayley é zero: posto 3 (ℝ e ℂ)."
    elif delta > 0:
        return "O hiperdeterminante de Cayley é positivo: posto 2 (ℝ e ℂ)."
    else:  # delta < 0
        return "O hiperdeterminante de Cayley é negativo: sobre ℝ: posto 3; sobre ℂ: posto 2."

if __name__ == "__main__":
    print(verificar_posto(lista))