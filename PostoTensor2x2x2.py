# -*- coding: utf-8 -*-
"""2x2x2posto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11zWMjCJw1Wpx6czbT2CXmjz5PzS1Zu8p
"""

import numpy as np
# Lista unidimensional com os 8 números
#Produto tensorial de três fatores, a=[a1, a2], b = [b1, b2], c = [c1, c2]
#a⊗b=[a1b1, a1b2, a2b1, a2b2]⊗c=[a1b1c1, a1b2c1, a2b1c1, a2b2c1, a1b1c2, a1b2c2, a2b1c2, a2b2c2]
# Lista unidimensional com os 8 números
#Hiperdeterminante 0
lista = [1, 0, 0, 1, 1, 1, 0, 1]
#Superdiagonal
#lista = [0, 0, 0, 1, 1, 0, 0, 0]
#Uma fatia multiplo escalar da outra
#lista = [-1, 7, 2, 0, -2, 14, 4, 0]
#Hiperdeterminante de Cayley negativo
#lista = [2, 0, 0, 1, 0, 3, -5, 0]
#Todas as fatias singulares
#lista = [-1, 0, 5, 0, -6, 0, 30, 0]
#Hiperdeterminante de Cayley positivo
#lista = [2, 5, -6, -8, 4, 10, -12, 0]
# Reorganizar a lista para coincidir com a forma desejada: 2x2x2
tensor = np.array([[[lista[0], lista[4]], [lista[1], lista[5]]],
                   [[lista[2], lista[6]], [lista[3], lista[7]]]])
# Mostrar fatias do tensor
def mostrar_fatias(tensor):
    # Fatias frontais (fixo k)
    print("Fatias frontais:")
    fatias_frontais = []
    for k in range(tensor.shape[2]):
        f = tensor[:, :, k]
        fatias_frontais.append(f)
        print(f"Fatia frontal k={k}:")
        print(f)

    # Fatias horizontais (fixo i)
    print("\nFatias horizontais:")
    fatias_horizontais = []
    for i in range(tensor.shape[0]):
        f = tensor[i, :, :]
        fatias_horizontais.append(f)
        print(f"Fatia horizontal i={i}:")
        print(f)

    # Fatias verticais (fixo j)
    print("\nFatias verticais:")
    fatias_verticais = []
    for j in range(tensor.shape[1]):
        f = tensor[:, j, :]
        fatias_verticais.append(f)
        print(f"Fatia vertical j={j}:")
        print(f)

    return fatias_frontais, fatias_horizontais, fatias_verticais


# Passo 1: verifica se a lista é nula
def passo_1(lista):
    return np.all(np.array(lista) == 0)


# Passo 2: verifica se a lista é superdiagonal
def passo_2(lista):
    if lista[0] != 0 and lista[7] != 0 and all(x == 0 for x in lista[1:7]):
        return True
    if lista[1] != 0 and lista[6] != 0 and all(x == 0 for x in [lista[0], lista[2], lista[3], lista[4], lista[5], lista[7]]):
        return True
    if lista[2] != 0 and lista[5] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[3], lista[4], lista[6], lista[7]]):
        return True
    if lista[3] != 0 and lista[4] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[2], lista[5], lista[6], lista[7]]):
        return True
    return False


# Passo 3: verifica se todas as fatias são singulares
def passo_3(lista):
    tensor = np.array([
        [[lista[0], lista[4]], [lista[1], lista[5]]],
        [[lista[2], lista[6]], [lista[3], lista[7]]]
    ])

    fatias_frontais, _, _ = mostrar_fatias(tensor)

    fatias_nao_singulares = []
    for fatia in fatias_frontais:
        if np.linalg.det(fatia) != 0:
            fatias_nao_singulares.append(fatia)

    return fatias_nao_singulares


# Verifica se duas matrizes são múltiplos escalares
def e_multiplo_escalar(matriz1, matriz2):
    if np.all(matriz1 == 0) or np.all(matriz2 == 0):
        return True
    indices = np.argwhere(matriz1 != 0)
    i, j = indices[0]
    ratio = matriz2[i, j] / matriz1[i, j]
    for x in range(matriz1.shape[0]):
        for y in range(matriz1.shape[1]):
            if not np.isclose(matriz2[x, y], ratio * matriz1[x, y]):
                return False
    return True


# Passo 4: verifica se há fatias múltiplos escalares
def passo_4(fatias_nao_singulares):
    if len(fatias_nao_singulares) < 2:
        return False
    for i in range(len(fatias_nao_singulares)):
        for j in range(i + 1, len(fatias_nao_singulares)):
            if e_multiplo_escalar(fatias_nao_singulares[i], fatias_nao_singulares[j]):
                return True
    return False


# Cálculo do hiperdeterminante de Cayley
def calcular_hiperdeterminante(lista):
    x_111, x_112, x_121, x_122, x_211, x_212, x_221, x_222 = lista

    term1 = x_111**2 * x_222**2 + x_112**2 * x_221**2 + x_121**2 * x_212**2 + x_122**2 * x_211**2
    term2 = 2 * (x_111 * x_112 * x_221 * x_222 + x_111 * x_121 * x_212 * x_222 +
                 x_111 * x_122 * x_211 * x_222 + x_112 * x_121 * x_212 * x_221 +
                 x_112 * x_122 * x_211 * x_221 + x_121 * x_122 * x_211 * x_212)
    term3 = 4 * (x_111 * x_122 * x_212 * x_221 + x_112 * x_121 * x_211 * x_222)

    return term1 - term2 + term3


# Passo 5: cálculo do posto a partir do hiperdeterminante
def passo_5(lista, campo="R"):
    delta = calcular_hiperdeterminante(lista)

    if campo == "R":  # Reais
        if delta > 0:
            return 2, delta
        elif delta == 0:
            return 3, delta
        else:  # delta < 0
            return 3, delta

    elif campo == "C":  # Complexos
        if delta != 0:
            return 2, delta
        else:
            return 3, delta


# Função principal
def verificar_posto(lista, campo="R"):
    # Passo 1: nula
    if passo_1(lista):
        return "A lista é nula, tem posto 0"

    # Passo 2: superdiagonal
    if passo_2(lista):
        return "A lista é superdiagonal, tem posto 2"

    # Passo 3: todas as fatias singulares
    fatias_nao_singulares = passo_3(lista)
    if len(fatias_nao_singulares) == 0:
        return "A lista é de posto 1, todas as fatias são singulares"

    # Passo 4: múltiplos escalares
    if passo_4(fatias_nao_singulares):
        return "A lista é de posto 2, pois uma fatia é múltiplo escalar de outra"

    # Passo 5: hiperdeterminante
    posto, delta = passo_5(lista, campo)
    print(f"\nValor numérico do hiperdeterminante de Cayley: {delta}")
    if campo == "R":
        if delta > 0:
            return "Δ(T) > 0 (ℝ): posto 2"
        elif delta == 0:
            return "Δ(T) = 0 (ℝ): posto 3"
        else:
            return "Δ(T) < 0 (ℝ): posto 3"
    else:  # campo == "C"
        if delta != 0:
            return "Δ(T) ≠ 0 (ℂ): posto 2"
        else:
            return "Δ(T) = 0 (ℂ): posto 3"

print(verificar_posto(lista, campo="R"))  # caso real
print(verificar_posto(lista, campo="C"))  # caso complexo