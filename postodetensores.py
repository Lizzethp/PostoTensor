# -*- coding: utf-8 -*-
"""PostodeTensores.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11zWMjCJw1Wpx6czbT2CXmjz5PzS1Zu8p
"""

# Posto de Tensores 2×2×2

#Este projeto implementa um algoritmo para verificar o posto de tensores 2×2×2 sobre os corpos reais (ℝ) e complexos (ℂ).

#O algoritmo:
# Analisa as fatias do tensor para verificar se são singulares.
# Detecta se existem fatias que são múltiplos escalares.
# Calcula o Hiperdeterminante de Cayley para distinguir casos especiais.
# Retorna um resultado textual indicando o posto do tensor de acordo com as condições do teorema aplicado.

## Primeiro, construímos um tensor a partir do produto tensorial de três fatores.
#Deixamos exemplos de listas nos comentários para calcular seu posto, caso o leitor queira testar os diferentes postos.
#Em seguida, começamos a testar as diferentes etapas: se a lista for nula, caso contrário, verificamos se ela é superdiagonal;
#caso contrário, verificamos se os fatores são singulares; se houver um que não seja,
#verificamos se há um fator não singular e um múltiplo de outro fator; caso contrário, passamos ao cálculo do hiperdeterminante de Cayley e,
# a partir daí, verificamos qual é o posto do tensor introduzido inicialmente.
import numpy as np
def produto_tensorial(a, b, c):
    """
    Calcula o produto tensorial de três vetores: a⊗b⊗c.

    Parâmetros:
    - a, b, c: vetores

    Retorna:
    - lista com 8 elementos
    """
    lista = []
    for ai in a:
        for bj in b:
            for ck in c:
                lista.append(ai * bj * ck)

    # Reorganizar em tensor 2x2x2
    tensor = np.array([[[lista[0], lista[4]], [lista[1], lista[5]]],
                       [[lista[2], lista[6]], [lista[3], lista[7]]]])

    return lista, tensor

if __name__ == "__main__":
    a = [1, -1]
    b = [3, 0]
    c = [-2, -2]

    lista, tensor = produto_tensorial(a, b, c)
    #Se você quer testar o posto do tensor construído, deixa assim. Se quer testor outro exemplo abaixo, colocar em comment o seguinte print
    print("Lista:", lista)


# Lista unidimensional com os 8 números
#Produto tensorial de três fatores, a=[a1, a2], b = [b1, b2], c = [c1, c2]
#a⊗b=[a1b1, a1b2, a2b1, a2b2]⊗c=[a1b1c1, a1b2c1, a2b1c1, a2b2c1, a1b1c2, a1b2c2, a2b1c2, a2b2c2]
# Lista unidimensional com os 8 números
#Hiperdeterminante 0
#lista = [1, 0, 0, 1, 1, 1, 0, 1]
#Superdiagonal
#lista = [0, 0, 0, 1, 1, 0, 0, 0]
#Uma fatia multiplo escalar da outra
#lista = [-1, 7, 2, 0, -2, 14, 4, 0]
#Hiperdeterminante de Cayley negativo
#lista = [2, 0, 0, 1, 0, 3, -5, 0]
#Todas as fatias singulares
#lista = [-1, 0, 5, 0, -6, 0, 30, 0]
#Hiperdeterminante de Cayley positivo
#lista = [2, 5, -6, -8, 4, 10, -12, 0]


# Reorganizar a lista para coincidir com a forma desejada: 2x2x2
tensor = np.array([[[lista[0], lista[4]], [lista[1], lista[5]]],
                   [[lista[2], lista[6]], [lista[3], lista[7]]]])
# Mostrar fatias do tensor
def mostrar_fatias(tensor):
    # Fatias frontais (fixo k)
    print("Fatias frontais:")
    fatias_frontais = []
    for k in range(tensor.shape[2]):
        f = tensor[:, :, k]
        fatias_frontais.append(f)
        print(f"Fatia frontal k={k}:")
        print(f)

    # Fatias horizontais (fixo i)
    print("\nFatias horizontais:")
    fatias_horizontais = []
    for i in range(tensor.shape[0]):
        f = tensor[i, :, :]
        fatias_horizontais.append(f)
        print(f"Fatia horizontal i={i}:")
        print(f)

    # Fatias verticais (fixo j)
    print("\nFatias verticais:")
    fatias_verticais = []
    for j in range(tensor.shape[1]):
        f = tensor[:, j, :]
        fatias_verticais.append(f)
        print(f"Fatia vertical j={j}:")
        print(f)

    return fatias_frontais, fatias_horizontais, fatias_verticais


# Passo 1: verifica se a lista é nula
def passo_1(lista):
    return np.all(np.array(lista) == 0)


# Passo 2: verifica se a lista é superdiagonal
def passo_2(lista):
    if lista[0] != 0 and lista[7] != 0 and all(x == 0 for x in lista[1:7]):
        return True
    if lista[1] != 0 and lista[6] != 0 and all(x == 0 for x in [lista[0], lista[2], lista[3], lista[4], lista[5], lista[7]]):
        return True
    if lista[2] != 0 and lista[5] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[3], lista[4], lista[6], lista[7]]):
        return True
    if lista[3] != 0 and lista[4] != 0 and all(x == 0 for x in [lista[0], lista[1], lista[2], lista[5], lista[6], lista[7]]):
        return True
    return False


# Passo 3: verifica se todas as fatias são singulares
def passo_3(lista, mostrar=False):
    tensor = np.array([
        [[lista[0], lista[4]], [lista[1], lista[5]]],
        [[lista[2], lista[6]], [lista[3], lista[7]]]
    ])

    if mostrar:
        fatias_frontais, _, _ = mostrar_fatias(tensor)
    else:

        fatias_frontais = [tensor[:, :, k] for k in range(tensor.shape[2])]

    fatias_nao_singulares = []
    for fatia in fatias_frontais:
        if abs(np.linalg.det(fatia)) > 1e-12:
            fatias_nao_singulares.append(fatia)

    return fatias_nao_singulares



# Verifica se duas matrizes são múltiplos escalares
def e_multiplo_escalar(matriz1, matriz2):
    if np.all(matriz1 == 0) or np.all(matriz2 == 0):
        return True
    indices = np.argwhere(matriz1 != 0)
    i, j = indices[0]
    ratio = matriz2[i, j] / matriz1[i, j]
    for x in range(matriz1.shape[0]):
        for y in range(matriz1.shape[1]):
            if not np.isclose(matriz2[x, y], ratio * matriz1[x, y]):
                return False
    return True


# Passo 4: verifica se há fatias múltiplos escalares
def passo_4(fatias_nao_singulares):
    if len(fatias_nao_singulares) < 2:
        return False
    for i in range(len(fatias_nao_singulares)):
        for j in range(i + 1, len(fatias_nao_singulares)):
            if e_multiplo_escalar(fatias_nao_singulares[i], fatias_nao_singulares[j]):
                return True
    return False


# Cálculo do hiperdeterminante de Cayley
def calcular_hiperdeterminante(lista):
    x_111, x_112, x_121, x_122, x_211, x_212, x_221, x_222 = lista

    term1 = x_111**2 * x_222**2 + x_112**2 * x_221**2 + x_121**2 * x_212**2 + x_122**2 * x_211**2
    term2 = 2 * (x_111 * x_112 * x_221 * x_222 + x_111 * x_121 * x_212 * x_222 +
                 x_111 * x_122 * x_211 * x_222 + x_112 * x_121 * x_212 * x_221 +
                 x_112 * x_122 * x_211 * x_221 + x_121 * x_122 * x_211 * x_212)
    term3 = 4 * (x_111 * x_122 * x_212 * x_221 + x_112 * x_121 * x_211 * x_222)

    return term1 - term2 + term3


# Passo 5: cálculo do posto a partir do hiperdeterminante
def passo_5(lista, corpo="R"):
    delta = calcular_hiperdeterminante(lista)

    if corpo == "R":  # Reais
        if delta > 0:
            return 2, delta
        elif delta == 0:
            return 3, delta
        else: #delta < 0
            return 3, delta

    elif corpo == "C":  # Complexos
        if delta != 0:
            return 2, delta
        else:
            return 3, delta


# Função principal
def verificar_posto(lista, corpo="R", mostrar=False):
    # Passo 1: nula
    if passo_1(lista):
        return "A lista é nula, tem posto 0"

    # Passo 2: superdiagonal
    if passo_2(lista):
        return "A lista é superdiagonal, tem posto 2"

    # Passo 3: todas as fatias singulares
    fatias_nao_singulares = passo_3(lista, mostrar=mostrar)
    if len(fatias_nao_singulares) == 0:
        return "A lista é de posto 1, todas as fatias são singulares"

    # Passo 4: múltiplos escalares
    if passo_4(fatias_nao_singulares):
        return "A lista é de posto 2, pois uma fatia é múltiplo escalar de outra"

    # Passo 5: Hiperdeterminante de Cayley
    posto_R, delta = passo_5(lista, "R")
    posto_C, _ = passo_5(lista, "C")

    if posto_R == 2:
        return f"Δ(T) = {delta} > 0 (ℝ) ou ≠ 0 (ℂ): posto 2"
    else:
        return f"Δ(T) = {delta}: posto 3"

print(verificar_posto(lista, mostrar=True))